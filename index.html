<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Cloud Speaking (Pro Version)</title>
    <style>
        /* Dark Theme UI Design */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #121212; color: #e0e0e0; margin: 0; padding: 20px; box-sizing: border-box; }
        h1 { background: #1f1f1f; color: #8ab4f8; padding: 15px; text-align: center; border-radius: 8px; margin-top: 0; font-size: 24px; border: 1px solid #333;}
        .section { background: #1e1e1e; padding: 15px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border: 1px solid #333;}
        .row { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; align-items: center; }
        .row label { font-weight: bold; min-width: 120px; color: #b3b3b3; }
        
        /* Form Elements Dark Mode */
        input[type="text"], input[type="number"], select, textarea { 
            padding: 10px; border: 1px solid #444; border-radius: 4px; flex-grow: 1; 
            font-family: inherit; background-color: #2d2d2d; color: #ffffff; 
        }
        input::placeholder, textarea::placeholder { color: #888; }
        textarea { width: 100%; resize: vertical; box-sizing: border-box; font-size: 16px; line-height: 1.6; }
        
        /* Buttons */
        button { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s; background: #444; color: #e0e0e0; }
        button:hover:not(:disabled) { filter: brightness(1.2); }
        button:disabled { opacity: 0.6; cursor: not-allowed; }
        
        .btn-primary { background: #8ab4f8; color: #121212; }
        .btn-success { background: #81c995; color: #121212; }
        .btn-danger { background: #f28b82; color: #121212; }
        
        /* Status & Audio */
        .status-box { background: #202124; color: #a8c7fa; padding: 10px; border-radius: 4px; border: 1px solid #444; font-family: monospace; white-space: pre-wrap; max-height: 150px; overflow-y: auto; }
        input[type="file"] { display: none; }
        audio { filter: invert(0.9) hue-rotate(180deg); }

        /* Character Counter Style */
        .char-count { margin-left: auto; color: #8ab4f8; font-family: monospace; font-size: 14px; font-weight: bold; background: #2d2d2d; padding: 5px 10px; border-radius: 4px; border: 1px solid #444;}
    </style>
</head>
<body>

    <h1>üéôÔ∏è Google Cloud Speaking</h1>

    <div class="section">
        <h3 style="color: #fff;">üîë API Key Management</h3>
        <div class="row">
            <label>Google AI Studio:</label>
            <input type="text" id="geminiKey" placeholder="no API key">
            <button onclick="saveKey('geminiKey')">Send (Save)</button>
            <button onclick="copyElement('geminiKey')">Copy</button>
            <button class="btn-danger" onclick="clearKey('geminiKey')">Clear</button>
        </div>
        <div class="row">
            <label>Google Cloud TTS:</label>
            <input type="text" id="cloudKey" placeholder="no API key">
            <button onclick="saveKey('cloudKey')">Send (Save)</button>
            <button onclick="copyElement('cloudKey')">Copy</button>
            <button class="btn-danger" onclick="clearKey('cloudKey')">Clear</button>
        </div>
    </div>

    <div class="section">
        <h3 style="color: #fff;">‚öôÔ∏è Global Settings</h3>
        <div class="row">
            <label>AI Text Model:</label>
            <select id="geminiModel">
                <option value="gemini-3-flash-preview" selected>Gemini 3 Flash Preview (Default)</option>
                <option value="gemini-flash-latest">Gemini Flash Latest</option>
                <option value="gemini-flash-lite-latest">Gemini Flash Lite Latest</option>
                <option value="gemini-2.5-flash">gemini-2.5-flash</option>
                <option value="gemini-3-pro-preview">gemini-3-pro-preview</option>
                <option value="gemini-3.1-pro-preview">Gemini 3.1 Pro Preview</option>
            </select>
        </div>
        <div class="row">
            <label>Cloud TTS Voice:</label>
            <select id="ttsVoice" onchange="loadPreset()">
                <option value="en-US-Journey-D" selected>en-US-Journey-D (Male - Natural/Deep)</option>
                <option value="en-US-Studio-Q">en-US-Studio-Q (Male - Studio)</option>
                <option value="en-US-Journey-F">en-US-Journey-F (Female - Natural)</option>
                <option value="en-US-Studio-O">en-US-Studio-O (Female - Studio)</option>
            </select>
            <label>Format:</label>
            <select id="audioFormat">
                <option value="MP3" selected>MP3 (Best for long audio/RAM)</option>
                <option value="LINEAR16">WAV (High Quality, Huge file size)</option>
            </select>
        </div>
        <div class="row">
            <label>Pitch (-20 to 20):</label>
            <input type="number" id="ttsPitch" value="-2.0" step="0.1">
            <label>Speaking Rate (0.25 to 4.0):</label>
            <input type="number" id="ttsRate" value="0.90" step="0.05">
            <label>Volume Gain (dB):</label>
            <input type="number" id="ttsVolume" value="0.0" step="0.5">
        </div>
        
        <div class="row" style="justify-content: space-between; margin-top: 15px;">
            <label>AI SSML Prompt Preset:</label>
            <select id="promptPresetSelect" onchange="loadPreset()" style="max-width: 400px; border-color: #8ab4f8;">
                <option value="dhamma">üßò‚Äç‚ôÇÔ∏è Calm Dhamma Narration (Default)</option>
                <option value="meditation">ü™∑ Deep Meditation & Philosophy</option>
                <option value="commercial">üé¨ Energetic Commercial (Sweets/Desserts)</option>
                <option value="youtube">üíª YouTube Tech/Tutorial Video</option>
            </select>
        </div>
        <div class="row">
            <textarea id="voicePrompt" rows="8">Please format the SSML for a Buddhist Dhamma narration in English...</textarea>
        </div>
    </div>

    <div class="section">
        <h3 style="color: #fff;">üìÑ Primary Audio Script</h3>
        <div class="row">
            <input type="file" id="filePrimary" accept=".txt" onchange="openFile(event, 'primaryScript')">
            <button onclick="document.getElementById('filePrimary').click()">Open (.txt)</button>
            <button onclick="saveFile('primaryScript', 'primary_audio_script.txt')">Save</button>
            <button onclick="copyElement('primaryScript')">Copy</button>
            <button class="btn-danger" onclick="clearElement('primaryScript')">Clear</button>
            <span class="char-count" id="countPrimary">0 Chars</span>
        </div>
        <textarea id="primaryScript" rows="12" placeholder="Paste your English text here..."></textarea>
    </div>

    <div class="section">
        <h3 style="color: #fff;">üìù SSML Audio Script</h3>
        <div class="row">
            <button id="btnGenerateSSML" class="btn-primary" onclick="generateSSML()">‚ú® Generate SSML from Script</button>
            <input type="file" id="fileSSML" accept=".txt" onchange="openFile(event, 'ssmlScript')">
            <button onclick="document.getElementById('fileSSML').click()">Open (.txt)</button>
            <button onclick="saveFile('ssmlScript', 'SSML_audio_script.txt')">Save</button>
            <button onclick="copyElement('ssmlScript')">Copy</button>
            <button class="btn-danger" onclick="clearElement('ssmlScript')">Clear</button>
            <span class="char-count" id="countSSML">0 Chars</span>
        </div>
        <textarea id="ssmlScript" rows="12" placeholder="Generated SSML will appear here..."></textarea>
    </div>

    <div class="section">
        <h3 style="color: #fff;">üéõÔ∏è Processing Controls & Output</h3>
        <div class="row">
            <label>Batch Size (Chars):</label>
            <input type="number" id="batchSize" value="3500">
            <label>Inter-batch Delay (Sec):</label>
            <input type="number" id="batchDelay" value="3" step="0.5">
        </div>
        <div class="row">
            <button class="btn-primary" onclick="previewAudio()">‚ñ∂Ô∏è Preview (First 5 sentences)</button>
            <button class="btn-success" onclick="startGeneration()">üöÄ Generate Full Audio</button>
            <button class="btn-danger" onclick="stopProcess()">‚èπÔ∏è Stop</button>
        </div>
        
        <h4 style="color: #fff; margin-bottom: 5px;">Status:</h4>
        <div class="row">
            <button onclick="copyElement('statusLog')">Copy Status</button>
        </div>
        <div id="statusLog" class="status-box">Ready.</div>

        <h4 style="color: #fff; margin-bottom: 5px;">Audio Player:</h4>
        <div class="row">
            <audio id="audioPlayer" controls style="width: 100%;"></audio>
        </div>
        <div class="row">
            <button class="btn-success" id="downloadBtn" onclick="downloadAudio()" disabled>üíæ Download Audio</button>
        </div>
    </div>

    <script>
        let isProcessing = false;
        let audioChunksBlob = []; 

        const promptPresets = {
            "dhamma": "Please format the SSML for a Buddhist Dhamma narration in English. The tone must be deep, calming, warm, empathetic, and trustworthy. Add appropriate <break time=\"...\"/> for breathing and contemplation.",
            "meditation": "Format the SSML for a guided meditation or deep philosophical reflection. Use extreme care with pacing. Insert frequent, long <break> tags between thoughts. The voice should be whisper-soft and profoundly serene.",
            "commercial": "Please format the SSML for a vibrant, energetic video advertisement promoting fun, colorful products. The tone should be enthusiastic, friendly, bright, and inviting. Keep the pacing upbeat.",
            "youtube": "Format the SSML for a YouTube tutorial. The tone should be clear, articulate, engaging, and professional. Use natural conversational pauses <break time=\"400ms\"/>."
        };

        // --- THE MASTER PROMPT CONTROLLER ---
        function loadPreset() {
            const selected = document.getElementById('promptPresetSelect').value;
            let basePrompt = promptPresets[selected];
            
            basePrompt += "\n\n*** CRITICAL SSML RULES FOR GOOGLE CLOUD TTS ***\n";
            basePrompt += "1. NEVER use the 'pitch' attribute.\n";
            basePrompt += "2. NEVER use <emphasis> tags.\n";
            basePrompt += "3. For <break> tags, ONLY use whole numbers with 'ms' or 's' (e.g., <break time=\"1500ms\"/>, <break time=\"2s\"/>). NEVER use decimals like 1.5s.\n";
            basePrompt += "4. You may use <prosody rate=\"...\"> to control speed, but ensure you ALWAYS close it with </prosody>.";
            
            document.getElementById('voicePrompt').value = basePrompt;
        }
        
        window.onload = () => {
            loadKey('geminiKey');
            loadKey('cloudKey');
            updateCharCount('primaryScript', 'countPrimary');
            updateCharCount('ssmlScript', 'countSSML');
            loadPreset(); 
        };

        document.getElementById('primaryScript').addEventListener('input', () => updateCharCount('primaryScript', 'countPrimary'));
        document.getElementById('ssmlScript').addEventListener('input', () => updateCharCount('ssmlScript', 'countSSML'));

        function updateCharCount(inputId, displayId) {
            const textLength = document.getElementById(inputId).value.length;
            document.getElementById(displayId).innerText = `${textLength.toLocaleString()} Chars`;
        }

        function saveKey(id) {
            const val = document.getElementById(id).value.trim();
            if(val) { localStorage.setItem(id, val); alert('Key saved to browser storage.'); }
        }
        function loadKey(id) {
            const val = localStorage.getItem(id);
            if(val) document.getElementById(id).value = val;
        }
        function clearKey(id) {
            localStorage.removeItem(id);
            document.getElementById(id).value = '';
            document.getElementById(id).placeholder = 'no API key';
        }

        function copyElement(id) {
            const el = document.getElementById(id);
            const text = el.tagName === 'DIV' ? el.innerText : el.value;
            navigator.clipboard.writeText(text).then(() => alert('Copied to clipboard.'));
        }
        function clearElement(id) {
            const el = document.getElementById(id);
            if(el.tagName === 'DIV') el.innerText = ''; else el.value = '';
            if(id === 'primaryScript') updateCharCount('primaryScript', 'countPrimary');
            if(id === 'ssmlScript') updateCharCount('ssmlScript', 'countSSML');
        }
        function logStatus(msg) {
            const box = document.getElementById('statusLog');
            box.innerText += `\n[${new Date().toLocaleTimeString()}] ${msg}`;
            box.scrollTop = box.scrollHeight;
        }

        function openFile(event, targetId) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const target = document.getElementById(targetId);
                const textToInsert = e.target.result;
                const startPos = target.selectionStart;
                const endPos = target.selectionEnd;
                target.value = target.value.substring(0, startPos) + textToInsert + target.value.substring(endPos, target.value.length);
                if(targetId === 'primaryScript') updateCharCount('primaryScript', 'countPrimary');
                if(targetId === 'ssmlScript') updateCharCount('ssmlScript', 'countSSML');
            };
            reader.readAsText(file);
            event.target.value = ''; 
        }
        function saveFile(sourceId, filename) {
            const text = document.getElementById(sourceId).value;
            if(!text) return alert("Nothing to save!");
            const blob = new Blob([text], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url; a.download = filename; a.click();
            URL.revokeObjectURL(url);
        }

        async function generateSSML() {
            const key = document.getElementById('geminiKey').value.trim();
            if(!key) return alert('Please enter Google AI Studio API key.');
            const script = document.getElementById('primaryScript').value.trim();
            if(!script) return alert('Primary script is empty.');
            
            const btn = document.getElementById('btnGenerateSSML');
            const originalText = btn.innerHTML;
            btn.innerHTML = '‚è≥ Processing... Please wait';
            btn.disabled = true;

            const model = document.getElementById('geminiModel').value;
            const promptInstruction = document.getElementById('voicePrompt').value;
            const fullPrompt = `System instructions: ${promptInstruction}\n\nTask: Convert the following text into valid SSML format. ONLY return the raw SSML code without any markdown blocks (like \`\`\`xml) or explanations. Ensure the whole text is wrapped in <speak></speak> tags.\n\nText:\n${script}`;

            logStatus("Generating SSML via Gemini...");
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }] })
                });
                const data = await response.json();
                if(data.error) throw new Error(data.error.message);
                
                let ssmlResult = data.candidates[0].content.parts[0].text;
                ssmlResult = ssmlResult.replace(/```xml/gi, '').replace(/```html/gi, '').replace(/```/g, '').trim();
                
                if(!ssmlResult.startsWith('<speak>')) ssmlResult = `<speak>\n${ssmlResult}`;
                if(!ssmlResult.endsWith('</speak>')) ssmlResult = `${ssmlResult}\n</speak>`;

                document.getElementById('ssmlScript').value = ssmlResult;
                updateCharCount('ssmlScript', 'countSSML');
                
                logStatus("SSML Generation Complete.");
            } catch (err) {
                logStatus(`Error generating SSML: ${err.message}`);
                alert("Error: " + err.message);
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        const delay = ms => new Promise(res => setTimeout(res, ms));

        function stopProcess() {
            if(isProcessing) {
                isProcessing = false;
                logStatus("Process interrupted by user. Compiling generated chunks...");
            }
        }

        function base64ToUint8Array(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes;
        }

        // --- ‚ú® THE SMART TRANSLATOR & SCRUBBER ‚ú® ---
        async function fetchTTS(ssmlText) {
            const voiceName = document.getElementById('ttsVoice').value;
            const key = document.getElementById('cloudKey').value.trim();
            const format = document.getElementById('audioFormat').value;
            
            let payload = {
                voice: { languageCode: "en-US", name: voiceName },
                audioConfig: { audioEncoding: format }
            };

            // ü§ñ ‡πÅ‡∏¢‡∏Å‡∏™‡∏°‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á Journey ‡∏Å‡∏±‡∏ö Studio
            if (voiceName.includes('Journey')) {
                // ‡πÇ‡∏´‡∏°‡∏î Journey: ‡∏ñ‡∏≠‡∏î‡∏£‡πà‡∏≤‡∏á SSML ‡∏Å‡∏•‡∏≤‡∏¢‡πÄ‡∏õ‡πá‡∏ô Plain Text
                let plainText = ssmlText;
                
                // ‡πÅ‡∏õ‡∏•‡∏á <break> ‡πÉ‡∏´‡πâ‡∏Å‡∏•‡∏≤‡∏¢‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏∏‡∏î‡πÑ‡∏Ç‡πà‡∏õ‡∏•‡∏≤ (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ Journey ‡πÄ‡∏ß‡πâ‡∏ô‡∏ß‡∏£‡∏£‡∏Ñ‡∏´‡∏≤‡∏¢‡πÉ‡∏à)
                plainText = plainText.replace(/<break[^>]*>/gi, ' ... '); 
                
                // ‡∏•‡πâ‡∏≤‡∏á‡∏ö‡∏≤‡∏á‡πÅ‡∏ó‡πá‡∏Å XML ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á <speak> ‡πÅ‡∏•‡∏∞ <prosody>)
                plainText = plainText.replace(/<[^>]+>/g, '');
                
                // ‡∏™‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô Text ‡πÄ‡∏û‡∏µ‡∏¢‡∏ß‡πÜ! ‡πÑ‡∏°‡πà‡∏°‡∏µ Error 100%
                payload.input = { text: plainText.trim() };
                
                // (Journey ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á Pitch ‡∏Å‡∏±‡∏ö Rate ‡πÑ‡∏õ‡∏Å‡∏ß‡∏ô‡πÉ‡∏à ‡πÄ‡∏•‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏ô‡∏ö‡πÑ‡∏õ)
                
            } else {
                // ‡πÇ‡∏´‡∏°‡∏î Studio: ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ SSML ‡πÉ‡∏´‡πâ‡πÄ‡∏ô‡∏µ‡πâ‡∏¢‡∏ö‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
                let cleanSSML = ssmlText;
                cleanSSML = cleanSSML.replace(/<emphasis[^>]*>/gi, '').replace(/<\/emphasis>/gi, '');
                cleanSSML = cleanSSML.replace(/pitch="[^"]*"/gi, ''); 
                cleanSSML = cleanSSML.replace(/<prosody\s+>/gi, '<prosody>'); 
                
                const openProsodyCount = (cleanSSML.match(/<prosody[^>]*>/gi) || []).length;
                const closeProsodyCount = (cleanSSML.match(/<\/prosody>/gi) || []).length;
                
                if (openProsodyCount > closeProsodyCount) {
                    cleanSSML = cleanSSML.replace(/<\/speak>/gi, '');
                    for(let i = 0; i < (openProsodyCount - closeProsodyCount); i++) {
                        cleanSSML += '</prosody>';
                    }
                    cleanSSML += '</speak>';
                }

                payload.input = { ssml: cleanSSML };
                
                // ‡πÅ‡∏ô‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Pitch/Rate ‡πÑ‡∏î‡πâ‡∏ï‡∏≤‡∏°‡∏õ‡∏Å‡∏ï‡∏¥
                payload.audioConfig.pitch = parseFloat(document.getElementById('ttsPitch').value);
                payload.audioConfig.speakingRate = parseFloat(document.getElementById('ttsRate').value);
                payload.audioConfig.volumeGainDb = parseFloat(document.getElementById('ttsVolume').value);
            }

            const response = await fetch(`https://texttospeech.googleapis.com/v1/text:synthesize?key=${key}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const data = await response.json();
            if(data.error) throw new Error(data.error.message);
            return data.audioContent;
        }

        function getOpenTags(ssml) {
            const openTags = [];
            const regex = /<(\/?)([a-zA-Z0-9\-:]+)([^>]*)>/g;
            let match;
            while ((match = regex.exec(ssml)) !== null) {
                const isClosing = match[1] === '/';
                const tagName = match[2].toLowerCase();
                const attributes = match[3];
                
                if (attributes.trim().endsWith('/')) continue;
                if (['break', 'mark'].includes(tagName)) continue;

                if (!isClosing) {
                    openTags.push({ name: tagName, full: match[0] });
                } else {
                    const index = openTags.map(t => t.name).lastIndexOf(tagName);
                    if (index !== -1) openTags.splice(index, 1);
                }
            }
            return openTags; 
        }

        async function previewAudio() {
            if(!document.getElementById('cloudKey').value) return alert("Missing Google Cloud API Key.");
            let ssml = document.getElementById('ssmlScript').value;
            if(!ssml) return alert("No SSML to preview.");
            
            logStatus("Generating Preview...");
            isProcessing = true;
            try {
                let innerText = ssml.replace(/<\/?speak>/gi, '').trim();
                let segments = innerText.split(/(?<=\.|\?|\!)\s+|\n\n/); 
                let previewText = segments.slice(0, 5).join(' '); 
                
                let tagsToClose = getOpenTags(previewText);
                for (let i = tagsToClose.length - 1; i >= 0; i--) {
                    previewText += `</${tagsToClose[i].name}>`;
                }
                
                const safeSSML = `<speak>${previewText}</speak>`;
                
                const audioBase64 = await fetchTTS(safeSSML);
                const format = document.getElementById('audioFormat').value === 'MP3' ? 'audio/mpeg' : 'audio/wav';
                const audioBlob = new Blob([base64ToUint8Array(audioBase64)], { type: format });
                
                const audioUrl = URL.createObjectURL(audioBlob);
                const player = document.getElementById('audioPlayer');
                player.src = audioUrl;
                player.play();
                logStatus("Preview ready and playing.");
            } catch(e) {
                logStatus("Preview Error: " + e.message);
            }
            isProcessing = false;
        }

        function chunkSSML(ssml, maxChars) {
            let chunks = [];
            let currentChunk = "";
            let innerText = ssml.replace(/<\/?speak>/gi, '').trim(); 
            let segments = innerText.split(/(?<=\.|\?|\!)\s+|\n\n/); 
            
            let activeTags = []; 
            
            for(let seg of segments) {
                if((currentChunk.length + seg.length) > maxChars) {
                    if(currentChunk.trim()) {
                        let chunkToPush = currentChunk.trim();
                        let tagsToClose = getOpenTags(chunkToPush);
                        for (let i = tagsToClose.length - 1; i >= 0; i--) {
                            chunkToPush += `</${tagsToClose[i].name}>`;
                        }
                        chunks.push(`<speak>${chunkToPush}</speak>`);
                        
                        activeTags = tagsToClose; 
                    }
                    currentChunk = activeTags.map(t => t.full).join('') + seg + " ";
                } else {
                    currentChunk += seg + " ";
                }
            }
            if(currentChunk.trim()) {
                let chunkToPush = currentChunk.trim();
                let tagsToClose = getOpenTags(chunkToPush);
                for (let i = tagsToClose.length - 1; i >= 0; i--) {
                    chunkToPush += `</${tagsToClose[i].name}>`;
                }
                chunks.push(`<speak>${chunkToPush}</speak>`);
            }
            return chunks;
        }

        async function startGeneration() {
            if(!document.getElementById('cloudKey').value) return alert("Missing Google Cloud API Key.");
            let ssml = document.getElementById('ssmlScript').value;
            if(!ssml) return alert("No SSML to process.");

            const batchSize = parseInt(document.getElementById('batchSize').value);
            const baseDelay = parseFloat(document.getElementById('batchDelay').value) * 1000;
            const format = document.getElementById('audioFormat').value === 'MP3' ? 'audio/mpeg' : 'audio/wav';

            const chunks = chunkSSML(ssml, batchSize);
            logStatus(`Starting generation. Total batches: ${chunks.length}`);
            
            isProcessing = true;
            audioChunksBlob = []; 
            document.getElementById('downloadBtn').disabled = true;

            for(let i = 0; i < chunks.length; i++) {
                if(!isProcessing) break; 

                logStatus(`Processing Batch ${i+1}/${chunks.length}... \nPreview: ${chunks[i].replace(/<[^>]+>/g, '').substring(0, 50)}...`);
                
                try {
                    const audioBase64 = await fetchTTS(chunks[i]);
                    audioChunksBlob.push(base64ToUint8Array(audioBase64));
                    
                    if(i < chunks.length - 1 && isProcessing) {
                        const jitter = Math.random() * 2000;
                        const waitTime = baseDelay + jitter;
                        logStatus(`Waiting ${(waitTime/1000).toFixed(1)}s before next batch...`);
                        await delay(waitTime);
                    }
                } catch(e) {
                    logStatus(`Error on batch ${i+1}: ${e.message}`);
                    isProcessing = false;
                    break;
                }
            }

            compileAudio(format);
        }

        function compileAudio(mimeType) {
            if(audioChunksBlob.length === 0) {
                logStatus("No audio generated.");
                return;
            }
            logStatus("Compiling audio chunks...");
            
            const finalBlob = new Blob(audioChunksBlob, { type: mimeType });
            const audioUrl = URL.createObjectURL(finalBlob);
            
            const player = document.getElementById('audioPlayer');
            player.src = audioUrl;
            
            const dBtn = document.getElementById('downloadBtn');
            dBtn.onclick = () => {
                const a = document.createElement("a");
                a.href = audioUrl;
                a.download = `Generated_Audio_${new Date().getTime()}.${mimeType === 'audio/mpeg' ? 'mp3' : 'wav'}`;
                a.click();
            };
            dBtn.disabled = false;
            
            isProcessing = false;
            logStatus(`‚úÖ Processing Complete! You can now play or download the audio.`);
        }
    </script>
</body>
</html>