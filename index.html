<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Cloud Speaking</title>
    <style>
        /* Flat UI Design - ‡πÑ‡∏°‡πà‡∏°‡∏µ Sticky ‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ç‡∏≠ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f4f7f6; color: #333; margin: 0; padding: 20px; box-sizing: border-box; }
        h1 { background: #4285F4; color: white; padding: 15px; text-align: center; border-radius: 8px; margin-top: 0; font-size: 24px;}
        .section { background: white; padding: 15px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .row { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; align-items: center; }
        .row label { font-weight: bold; min-width: 120px; }
        input[type="text"], input[type="number"], select, textarea { padding: 10px; border: 1px solid #ccc; border-radius: 4px; flex-grow: 1; font-family: inherit; }
        textarea { width: 100%; resize: vertical; box-sizing: border-box; font-size: 16px; line-height: 1.5;}
        button { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: background 0.2s; background: #e0e0e0; color: #333;}
        button:hover { filter: brightness(0.9); }
        .btn-primary { background: #4285F4; color: white; }
        .btn-success { background: #0F9D58; color: white; }
        .btn-danger { background: #DB4437; color: white; }
        .status-box { background: #e8f0fe; padding: 10px; border-radius: 4px; font-family: monospace; white-space: pre-wrap; max-height: 150px; overflow-y: auto; }
        input[type="file"] { display: none; }
    </style>
</head>
<body>

    <h1>üéôÔ∏è Google Cloud Speaking</h1>

    <div class="section">
        <h3>üîë API Key Management</h3>
        <div class="row">
            <label>Google AI Studio:</label>
            <input type="text" id="geminiKey" placeholder="no API key">
            <button onclick="saveKey('geminiKey')">Send (Save)</button>
            <button onclick="copyElement('geminiKey')">Copy</button>
            <button class="btn-danger" onclick="clearKey('geminiKey')">Clear</button>
        </div>
        <div class="row">
            <label>Google Cloud TTS:</label>
            <input type="text" id="cloudKey" placeholder="no API key">
            <button onclick="saveKey('cloudKey')">Send (Save)</button>
            <button onclick="copyElement('cloudKey')">Copy</button>
            <button class="btn-danger" onclick="clearKey('cloudKey')">Clear</button>
        </div>
    </div>

    <div class="section">
        <h3>‚öôÔ∏è Global Settings</h3>
        <div class="row">
            <label>AI Text Model:</label>
            <select id="geminiModel">
                <option value="gemini-3.0-flash-preview">gemini-3.0-flash-preview</option>
                <option value="gemini-3.0-pro-preview">gemini-3.0-pro-preview</option>
                <option value="gemini-2.5-flash" selected>gemini-2.5-flash (Recommended)</option>
                <option value="gemini-2.5-pro">gemini-2.5-pro</option>
                <option value="gemini-1.5-pro">gemini-1.5-pro</option>
            </select>
        </div>
        <div class="row">
            <label>Cloud TTS Voice:</label>
            <select id="ttsVoice">
                <option value="en-US-Journey-D" selected>en-US-Journey-D (Male - Natural/Deep)</option>
                <option value="en-US-Studio-Q">en-US-Studio-Q (Male - Studio)</option>
                <option value="en-US-Journey-F">en-US-Journey-F (Female - Natural)</option>
                <option value="en-US-Studio-O">en-US-Studio-O (Female - Studio)</option>
            </select>
            <label>Format:</label>
            <select id="audioFormat">
                <option value="MP3" selected>MP3 (Best for long audio/RAM)</option>
                <option value="LINEAR16">WAV (High Quality, Huge file size)</option>
            </select>
        </div>
        <div class="row">
            <label>Pitch (-20 to 20):</label>
            <input type="number" id="ttsPitch" value="-2.0" step="0.1" title="Lower pitch for calming tone">
            <label>Speaking Rate (0.25 to 4.0):</label>
            <input type="number" id="ttsRate" value="0.90" step="0.05" title="Slower rate for Buddhist narration">
            <label>Volume Gain (dB):</label>
            <input type="number" id="ttsVolume" value="0.0" step="0.5">
        </div>
        <div class="row">
            <label style="width: 100%;">Additional Voice Details (For AI SSML Generation):</label>
            <textarea id="voicePrompt" rows="3">Please format the SSML for a Buddhist Dhamma narration in English. The target audience has basic English skills. The tone must be deep, calming, warm, empathetic, and trustworthy. Add appropriate <break time="..."/> for breathing and contemplation. Emphasize key Buddhist terms gently.</textarea>
        </div>
    </div>

    <div class="section">
        <h3>üìÑ Primary Audio Script</h3>
        <div class="row">
            <input type="file" id="filePrimary" accept=".txt" onchange="openFile(event, 'primaryScript')">
            <button onclick="document.getElementById('filePrimary').click()">Open (.txt)</button>
            <button onclick="saveFile('primaryScript', 'primary audio script.txt')">Save</button>
            <button onclick="copyElement('primaryScript')">Copy</button>
            <button class="btn-danger" onclick="clearElement('primaryScript')">Clear</button>
        </div>
        <textarea id="primaryScript" rows="15" placeholder="Paste your English text here..."></textarea>
    </div>

    <div class="section">
        <h3>üìù SSML Audio Script</h3>
        <div class="row">
            <button class="btn-primary" onclick="generateSSML()">‚ú® Generate SSML from Script</button>
            <input type="file" id="fileSSML" accept=".txt" onchange="openFile(event, 'ssmlScript')">
            <button onclick="document.getElementById('fileSSML').click()">Open (.txt)</button>
            <button onclick="saveFile('ssmlScript', 'SSML audio script.txt')">Save</button>
            <button onclick="copyElement('ssmlScript')">Copy</button>
            <button class="btn-danger" onclick="clearElement('ssmlScript')">Clear</button>
        </div>
        <textarea id="ssmlScript" rows="15" placeholder="Generated SSML will appear here..."></textarea>
    </div>

    <div class="section">
        <h3>üéõÔ∏è Processing Controls & Output</h3>
        <div class="row">
            <label>Batch Size (Chars):</label>
            <input type="number" id="batchSize" value="3500">
            <label>Inter-batch Delay (Sec):</label>
            <input type="number" id="batchDelay" value="3" step="0.5" title="Base delay. Random jitter (0-2s) will be added automatically.">
        </div>
        <div class="row">
            <button class="btn-primary" onclick="previewAudio()">‚ñ∂Ô∏è Preview (First 5 sentences)</button>
            <button class="btn-success" onclick="startGeneration()">üöÄ Generate Full Audio</button>
            <button class="btn-danger" onclick="stopProcess()">‚èπÔ∏è Stop</button>
        </div>
        
        <h4>Status:</h4>
        <div class="row">
            <button onclick="copyElement('statusLog')">Copy Status</button>
        </div>
        <div id="statusLog" class="status-box">Ready.</div>

        <h4>Audio Player:</h4>
        <div class="row">
            <audio id="audioPlayer" controls style="width: 100%;"></audio>
        </div>
        <div class="row">
            <button class="btn-success" id="downloadBtn" onclick="downloadAudio()" disabled>üíæ Download Audio</button>
        </div>
    </div>

    <script>
        let isProcessing = false;
        let audioChunksBlob = []; // Store chunks in RAM efficiently
        
        // --- Initialization ---
        window.onload = () => {
            loadKey('geminiKey');
            loadKey('cloudKey');
        };

        // --- Key Management ---
        function saveKey(id) {
            const val = document.getElementById(id).value.trim();
            if(val) { localStorage.setItem(id, val); alert('Key saved to browser storage.'); }
        }
        function loadKey(id) {
            const val = localStorage.getItem(id);
            if(val) document.getElementById(id).value = val;
        }
        function clearKey(id) {
            localStorage.removeItem(id);
            document.getElementById(id).value = '';
            document.getElementById(id).placeholder = 'no API key';
        }

        // --- Utility Functions ---
        function copyElement(id) {
            const el = document.getElementById(id);
            const text = el.tagName === 'DIV' ? el.innerText : el.value;
            navigator.clipboard.writeText(text).then(() => alert('Copied to clipboard.'));
        }
        function clearElement(id) {
            const el = document.getElementById(id);
            if(el.tagName === 'DIV') el.innerText = ''; else el.value = '';
        }
        function logStatus(msg) {
            const box = document.getElementById('statusLog');
            box.innerText += `\n[${new Date().toLocaleTimeString()}] ${msg}`;
            box.scrollTop = box.scrollHeight;
        }

        // --- File I/O ---
        function openFile(event, targetId) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const target = document.getElementById(targetId);
                const textToInsert = e.target.result;
                // Insert at cursor position
                const startPos = target.selectionStart;
                const endPos = target.selectionEnd;
                target.value = target.value.substring(0, startPos) + textToInsert + target.value.substring(endPos, target.value.length);
            };
            reader.readAsText(file);
            event.target.value = ''; // reset file input
        }
        function saveFile(sourceId, filename) {
            const text = document.getElementById(sourceId).value;
            if(!text) return alert("Nothing to save!");
            const blob = new Blob([text], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url; a.download = filename; a.click();
            URL.revokeObjectURL(url);
        }

        // --- Gemini AI (Text to SSML) ---
        async function generateSSML() {
            const key = document.getElementById('geminiKey').value.trim();
            if(!key) return alert('Please enter Google AI Studio API key.');
            const script = document.getElementById('primaryScript').value.trim();
            if(!script) return alert('Primary script is empty.');
            
            const model = document.getElementById('geminiModel').value;
            const promptInstruction = document.getElementById('voicePrompt').value;
            const fullPrompt = `System instructions: ${promptInstruction}\n\nTask: Convert the following text into valid SSML format. ONLY return the raw SSML code without any markdown blocks (like \`\`\`xml) or explanations. Ensure the whole text is wrapped in <speak></speak> tags.\n\nText:\n${script}`;

            logStatus("Generating SSML via Gemini...");
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }] })
                });
                const data = await response.json();
                if(data.error) throw new Error(data.error.message);
                
                let ssmlResult = data.candidates[0].content.parts[0].text;
                // Clean up markdown if AI ignored instructions
                ssmlResult = ssmlResult.replace(/```xml/gi, '').replace(/```/g, '').trim();
                document.getElementById('ssmlScript').value = ssmlResult;
                logStatus("SSML Generation Complete.");
            } catch (err) {
                logStatus(`Error generating SSML: ${err.message}`);
                alert("Error: " + err.message);
            }
        }

        // --- Audio Generation Core ---
        const delay = ms => new Promise(res => setTimeout(res, ms));

        function stopProcess() {
            if(isProcessing) {
                isProcessing = false;
                logStatus("Process interrupted by user. Compiling generated chunks...");
            }
        }

        // Convert Base64 from Google TTS to Uint8Array (RAM efficient)
        function base64ToUint8Array(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes;
        }

        async function fetchTTS(ssmlText) {
            const key = document.getElementById('cloudKey').value.trim();
            const format = document.getElementById('audioFormat').value;
            const payload = {
                input: { ssml: ssmlText },
                voice: { languageCode: "en-US", name: document.getElementById('ttsVoice').value },
                audioConfig: { 
                    audioEncoding: format,
                    pitch: parseFloat(document.getElementById('ttsPitch').value),
                    speakingRate: parseFloat(document.getElementById('ttsRate').value),
                    volumeGainDb: parseFloat(document.getElementById('ttsVolume').value)
                }
            };

            const response = await fetch(`https://texttospeech.googleapis.com/v1/text:synthesize?key=${key}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const data = await response.json();
            if(data.error) throw new Error(data.error.message);
            return data.audioContent;
        }

        function extractSentencesForPreview(ssml) {
            // Very basic extraction of first 5 sentences for preview, keeping <speak> tags
            const innerText = ssml.replace(/<\/?speak>/gi, '');
            const sentences = innerText.match(/[^\.!\?]+[\.!\?]+/g) || [innerText];
            const previewText = sentences.slice(0, 5).join(' ');
            return `<speak>${previewText}</speak>`;
        }

        // Simple chunking algorithm that tries not to break SSML tags
        function chunkSSML(ssml, maxChars) {
            let chunks = [];
            let currentChunk = "";
            let innerText = ssml.replace(/<\/?speak>/gi, ''); // remove root tags for splitting
            
            // Split by double newline or period to keep context
            let segments = innerText.split(/(?<=\.)\s+|\n\n/); 
            
            for(let seg of segments) {
                if((currentChunk.length + seg.length) > maxChars) {
                    if(currentChunk) chunks.push(`<speak>${currentChunk.trim()}</speak>`);
                    currentChunk = seg + " ";
                } else {
                    currentChunk += seg + " ";
                }
            }
            if(currentChunk.trim()) chunks.push(`<speak>${currentChunk.trim()}</speak>`);
            return chunks;
        }

        async function previewAudio() {
            if(!document.getElementById('cloudKey').value) return alert("Missing Google Cloud API Key.");
            let ssml = document.getElementById('ssmlScript').value;
            if(!ssml) return alert("No SSML to preview.");
            
            logStatus("Generating Preview...");
            isProcessing = true;
            try {
                const previewSSML = extractSentencesForPreview(ssml);
                const audioBase64 = await fetchTTS(previewSSML);
                const format = document.getElementById('audioFormat').value === 'MP3' ? 'audio/mpeg' : 'audio/wav';
                const audioBlob = new Blob([base64ToUint8Array(audioBase64)], { type: format });
                
                const audioUrl = URL.createObjectURL(audioBlob);
                const player = document.getElementById('audioPlayer');
                player.src = audioUrl;
                player.play();
                logStatus("Preview ready and playing.");
            } catch(e) {
                logStatus("Preview Error: " + e.message);
            }
            isProcessing = false;
        }

        async function startGeneration() {
            if(!document.getElementById('cloudKey').value) return alert("Missing Google Cloud API Key.");
            let ssml = document.getElementById('ssmlScript').value;
            if(!ssml) return alert("No SSML to process.");

            const batchSize = parseInt(document.getElementById('batchSize').value);
            const baseDelay = parseFloat(document.getElementById('batchDelay').value) * 1000;
            const format = document.getElementById('audioFormat').value === 'MP3' ? 'audio/mpeg' : 'audio/wav';

            const chunks = chunkSSML(ssml, batchSize);
            logStatus(`Starting generation. Total batches: ${chunks.length}`);
            
            isProcessing = true;
            audioChunksBlob = []; // Reset RAM
            document.getElementById('downloadBtn').disabled = true;

            for(let i = 0; i < chunks.length; i++) {
                if(!isProcessing) break; // Check for stop button

                logStatus(`Processing Batch ${i+1}/${chunks.length}... \nPreview: ${chunks[i].substring(0, 50)}...`);
                
                try {
                    const audioBase64 = await fetchTTS(chunks[i]);
                    // Convert to binary immediately to save RAM (Base64 strings take up much more memory)
                    audioChunksBlob.push(base64ToUint8Array(audioBase64));
                    
                    if(i < chunks.length - 1 && isProcessing) {
                        // Add random jitter to avoid bot detection (0 to 2 seconds extra)
                        const jitter = Math.random() * 2000;
                        const waitTime = baseDelay + jitter;
                        logStatus(`Waiting ${(waitTime/1000).toFixed(1)}s before next batch...`);
                        await delay(waitTime);
                    }
                } catch(e) {
                    logStatus(`Error on batch ${i+1}: ${e.message}`);
                    isProcessing = false;
                    break;
                }
            }

            compileAudio(format);
        }

        function compileAudio(mimeType) {
            if(audioChunksBlob.length === 0) {
                logStatus("No audio generated.");
                return;
            }
            logStatus("Compiling audio chunks...");
            
            // Concatenate all Uint8Arrays into a single Blob
            // For MP3, appending raw binary frames usually plays perfectly fine in Capcut
            const finalBlob = new Blob(audioChunksBlob, { type: mimeType });
            const audioUrl = URL.createObjectURL(finalBlob);
            
            const player = document.getElementById('audioPlayer');
            player.src = audioUrl;
            
            // Enable download
            const dBtn = document.getElementById('downloadBtn');
            dBtn.onclick = () => {
                const a = document.createElement("a");
                a.href = audioUrl;
                a.download = `Generated_Audio_${new Date().getTime()}.${mimeType === 'audio/mpeg' ? 'mp3' : 'wav'}`;
                a.click();
            };
            dBtn.disabled = false;
            
            isProcessing = false;
            logStatus(`‚úÖ Processing Complete! You can now play or download the audio.`);
            
            // Suggest garbage collection by clearing reference to large array if needed
            // audioChunksBlob = []; (We keep it here in case they want to download multiple times)
        }
    </script>
</body>
</html>