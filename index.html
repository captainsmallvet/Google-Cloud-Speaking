<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Cloud Speaking (Ultimate Studio Version)</title>
    <style>
        /* Dark Theme UI Design */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #121212; color: #e0e0e0; margin: 0; padding: 20px; box-sizing: border-box; }
        h1 { background: #1f1f1f; color: #8ab4f8; padding: 15px; text-align: center; border-radius: 8px; margin-top: 0; font-size: 24px; border: 1px solid #333;}
        .section { background: #1e1e1e; padding: 15px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border: 1px solid #333;}
        .row { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px; align-items: center; }
        .row label { font-weight: bold; min-width: 130px; color: #b3b3b3; }
        
        /* Form Elements Dark Mode */
        input[type="text"], input[type="number"], select, textarea { 
            padding: 10px; border: 1px solid #444; border-radius: 4px; flex-grow: 1; 
            font-family: inherit; background-color: #2d2d2d; color: #ffffff; 
        }
        input::placeholder, textarea::placeholder { color: #888; }
        textarea { width: 100%; resize: vertical; box-sizing: border-box; font-size: 16px; line-height: 1.6; }
        
        /* Sliders */
        input[type="range"] { flex-grow: 1; accent-color: #8ab4f8; cursor: pointer; }
        .val-display { background: #333; padding: 5px 10px; border-radius: 4px; font-family: monospace; font-weight: bold; min-width: 60px; text-align: center; color: #8ab4f8;}

        /* Buttons */
        button { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s; background: #444; color: #e0e0e0; }
        button:hover:not(:disabled) { filter: brightness(1.2); }
        button:disabled { opacity: 0.6; cursor: not-allowed; }
        
        .btn-primary { background: #8ab4f8; color: #121212; }
        .btn-success { background: #81c995; color: #121212; }
        .btn-danger { background: #f28b82; color: #121212; }
        .btn-warning { background: #f6aea9; color: #121212; }
        
        /* Status & Audio */
        .status-box { background: #202124; color: #a8c7fa; padding: 10px; border-radius: 4px; border: 1px solid #444; font-family: monospace; white-space: pre-wrap; max-height: 150px; overflow-y: auto; }
        input[type="file"] { display: none; }
        audio { filter: invert(0.9) hue-rotate(180deg); width: 100%; }

        /* Character Counter Style */
        .char-count { margin-left: auto; color: #8ab4f8; font-family: monospace; font-size: 14px; font-weight: bold; background: #2d2d2d; padding: 5px 10px; border-radius: 4px; border: 1px solid #444;}
    </style>
</head>
<body>

    <h1>üéôÔ∏è Google Cloud Speaking (Ultimate Studio)</h1>

    <div class="section">
        <h3 style="color: #fff;">üîë API Key Management</h3>
        <div class="row">
            <label>Google Cloud TTS:</label>
            <input type="text" id="cloudKey" placeholder="Required for Audio Generation">
            <button onclick="saveKey('cloudKey')">Save</button>
        </div>
        <div class="row">
            <label>Google AI Studio:</label>
            <input type="text" id="geminiKey" placeholder="Optional (Only needed if using AI Text Refiner)">
            <button onclick="saveKey('geminiKey')">Save</button>
        </div>
    </div>

    <div class="section">
        <h3 style="color: #fff;">üìù Final Audio Script (Auto-SSML)</h3>
        <p style="color: #888; margin-top: 0; font-size: 14px;">Paste your English or Thai text here. The system will automatically wrap it in SSML tags before generating audio.</p>
        <div class="row">
            <input type="file" id="fileScript" accept=".txt" onchange="openFile(event, 'audioScript')">
            <button onclick="document.getElementById('fileScript').click()">Open (.txt)</button>
            <button onclick="saveFile('audioScript', 'My_Audio_Script.txt')">Save Script</button>
            <button onclick="copyElement('audioScript')">Copy</button>
            <button class="btn-danger" onclick="clearElement('audioScript')">Clear</button>
            <span class="char-count" id="countScript">0 Chars</span>
        </div>
        <textarea id="audioScript" rows="12" placeholder="Example: Struggling with a chaotic mind? This isn't just ancient wisdom; it's the Buddha's precise path to inner peace."></textarea>
    </div>

    <div class="section">
        <h3 style="color: #fff;">üéõÔ∏è Processing Controls & Sliders</h3>
       
    <div>
        <h3 style="color: #fff;">‚öôÔ∏è Voice Selection</h3>
        <div class="row">
            <label>Voice Model:</label>
            <select id="ttsVoice">
                <optgroup label="Polyglot (Preview) - Multi-Language Voice">
                    <option value="en-US-Polyglot-1" data-lang="en-US">en-US-Polyglot-1 (Speaking English US)</option>
                    <option value="en-US-Polyglot-1" data-lang="th-TH">en-US-Polyglot-1 (Speaking Thai)</option>
                </optgroup>
                <optgroup label="Chirp 3: HD (Next-Gen AI - Highly Natural & Emotional)">
                    <option value="en-US-Chirp3-HD-Enceladus" data-lang="en-US">en-US-Chirp3-HD-Enceladus (Male - Energetic/Promo)</option>
                    <option value="en-US-Chirp3-HD-Iapetus" data-lang="en-US">en-US-Chirp3-HD-Iapetus (Male - Friendly/Casual)</option>
                    <option value="en-US-Chirp3-HD-Charon" data-lang="en-US">en-US-Chirp3-HD-Charon (Male - Informative)</option>
                    <option value="en-US-Chirp3-HD-Puck" data-lang="en-US">en-US-Chirp3-HD-Puck (Male - Upbeat)</option>
                    <option value="en-US-Chirp3-HD-Fenrir" data-lang="en-US">en-US-Chirp3-HD-Fenrir (Male - Excitable)</option>
                    <option value="en-US-Chirp3-HD-Aoede" data-lang="en-US">en-US-Chirp3-HD-Aoede (Female - Breezy)</option>
                    <option value="en-US-Chirp3-HD-Zephyr" data-lang="en-US">en-US-Chirp3-HD-Zephyr (Female - Bright)</option>
                    <option value="en-US-Chirp3-HD-Kore" data-lang="en-US">en-US-Chirp3-HD-Kore (Female - Firm)</option>
                </optgroup>
                <optgroup label="Neural2 (Recommended - High Quality & Pitch Adjustable)">
                    <option value="en-US-Neural2-J" data-lang="en-US" selected>en-US-Neural2-J (Male - Deep/Authoritative)</option>
                    <option value="en-US-Neural2-I" data-lang="en-US">en-US-Neural2-I (Male - Smooth/Calm)</option>
                    <option value="en-US-Neural2-D" data-lang="en-US">en-US-Neural2-D (Male - Mature)</option>
                    <option value="en-US-Neural2-A" data-lang="en-US">en-US-Neural2-A (Male - Standard)</option>
                    <option value="en-US-Neural2-C" data-lang="en-US">en-US-Neural2-C (Female - Soft)</option>
                    <option value="en-US-Neural2-E" data-lang="en-US">en-US-Neural2-E (Female - Articulate)</option>
                    <option value="en-US-Neural2-F" data-lang="en-US">en-US-Neural2-F (Female - Bright)</option>
                    <option value="en-US-Neural2-G" data-lang="en-US">en-US-Neural2-G (Female - Gentle)</option>
                    <option value="en-US-Neural2-H" data-lang="en-US">en-US-Neural2-H (Female - Warm)</option>
                </optgroup>
                <optgroup label="Studio (High Quality - Fixed Pitch)">
                    <option value="en-US-Studio-Q" data-lang="en-US">en-US-Studio-Q (Male - Studio Broadcast)</option>
                    <option value="en-US-Studio-O" data-lang="en-US">en-US-Studio-O (Female - Studio Broadcast)</option>
                </optgroup>
                <optgroup label="Journey (Natural AI - No Prosody Allowed)">
                    <option value="en-US-Journey-D" data-lang="en-US">en-US-Journey-D (Male - Natural)</option>
                    <option value="en-US-Journey-F" data-lang="en-US">en-US-Journey-F (Female - Natural)</option>
                </optgroup>
            </select>
            <label>Format:</label>
            <select id="audioFormat">
                <option value="MP3" selected>MP3 (Best for long audio)</option>
                <option value="LINEAR16">WAV (High Quality)</option>
            </select>
        </div>
    </div>

        <div class="row">
            <label>Prosody Rate:</label>
            <input type="range" id="ttsRate" min="25" max="400" value="80" oninput="updateSlider('ttsRate', 'rateVal', '%')">
            <span class="val-display" id="rateVal">80%</span>
        </div>
        <div class="row">
            <label>Prosody Pitch:</label>
            <input type="range" id="ttsPitch" min="-20" max="20" value="5" oninput="updateSlider('ttsPitch', 'pitchVal', '%')">
            <span class="val-display" id="pitchVal">5%</span>
        </div>
        <div class="row">
            <label>Volume Gain:</label>
            <input type="range" id="ttsVolume" min="-10" max="10" step="0.5" value="0" oninput="updateSlider('ttsVolume', 'volVal', ' dB')">
            <span class="val-display" id="volVal">0 dB</span>
        </div>

        <div class="row" style="margin-top: 20px;">
            <label>Batch Size (Chars):</label>
            <input type="number" id="batchSize" value="3500">
            <label>Inter-batch Delay (Sec):</label>
            <input type="number" id="batchDelay" value="3" step="0.5">
        </div>
        
        <div class="row" style="margin-top: 15px;">
            <button class="btn-primary" onclick="previewAudio()">‚ñ∂Ô∏è Preview Audio (First chunk)</button>
            <button class="btn-success" onclick="startGeneration()">üöÄ Generate Full Audio</button>
            <button class="btn-danger" onclick="stopProcess()">‚èπÔ∏è Stop</button>
        </div>
        
        <h4 style="color: #fff; margin-bottom: 5px;">Status Log:</h4>
        <div id="statusLog" class="status-box">Ready.</div>

        <h4 style="color: #fff; margin-bottom: 5px;">Audio Output:</h4>
        <div class="row">
            <audio id="audioPlayer" controls></audio>
        </div>
        <div class="row">
            <button class="btn-success" id="downloadBtn" onclick="downloadAudio()" disabled>üíæ Download Audio</button>
        </div>
    </div>

    <div class="section" style="border-color: #555;">
        <h3 style="color: #fff;">ü§ñ AI Text Refiner (Optional: English Corrector)</h3>
        <p style="color: #888; font-size: 14px; margin-top: 0;">Use this section ONLY if you want Gemini to correct grammar or improve the tone of your text. It outputs plain text to be copied into the Audio Script above.</p>
        <div class="row">
            <select id="geminiModel">
                <option value="gemini-3-flash-preview" selected>Gemini 3 Flash Preview</option>
                <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
            </select>
            <select id="promptPresetSelect" onchange="loadPreset()" style="flex-grow: 2;">
                <option value="dhamma">üßò‚Äç‚ôÇÔ∏è Improve Grammar & Apply Dhamma Tone</option>
                <option value="grammar">‚úçÔ∏è Just Correct Grammar</option>
            </select>
        </div>
        <div class="row">
            <textarea id="voicePrompt" rows="3"></textarea>
        </div>
        <div class="row">
            <textarea id="draftScript" rows="6" placeholder="Paste rough draft here..."></textarea>
        </div>
        <div class="row">
            <button class="btn-warning" id="btnRefine" onclick="refineText()">‚ú® Refine Text via Gemini</button>
        </div>
    </div>

    <script>
        let isProcessing = false;
        let audioChunksBlob = []; 

        const promptPresets = {
            "dhamma": "Rewrite the following text for a Buddhist Dhamma narration. Correct any grammatical errors. Make the English natural, flowing, and profound. The tone must be deep, calming, warm, empathetic, and trustworthy. DO NOT output any markdown, XML, or SSML tags. Output ONLY the refined plain text.",
            "grammar": "Correct the grammar and punctuation of the following English text. Make it sound natural for a native speaker. Output ONLY the refined plain text without any formatting or conversational filler."
        };

        function loadPreset() {
            document.getElementById('voicePrompt').value = promptPresets[document.getElementById('promptPresetSelect').value];
        }

        function updateSlider(sliderId, displayId, suffix) {
            let val = document.getElementById(sliderId).value;
            if (val > 0 && suffix === '%') val = '+' + val;
            if (val > 0 && suffix === ' dB') val = '+' + val;
            document.getElementById(displayId).innerText = val + suffix;
        }
        
        window.onload = () => {
            loadKey('geminiKey');
            loadKey('cloudKey');
            updateCharCount('audioScript', 'countScript');
            loadPreset(); 
        };

        document.getElementById('audioScript').addEventListener('input', () => updateCharCount('audioScript', 'countScript'));

        function updateCharCount(inputId, displayId) {
            const textLength = document.getElementById(inputId).value.length;
            document.getElementById(displayId).innerText = `${textLength.toLocaleString()} Chars`;
        }

        function saveKey(id) {
            const val = document.getElementById(id).value.trim();
            if(val) { localStorage.setItem(id, val); alert('Key saved.'); }
        }
        function loadKey(id) {
            const val = localStorage.getItem(id);
            if(val) document.getElementById(id).value = val;
        }
        function clearKey(id) {
            localStorage.removeItem(id);
            document.getElementById(id).value = '';
        }

        function copyElement(id) {
            const el = document.getElementById(id);
            navigator.clipboard.writeText(el.value).then(() => alert('Copied to clipboard.'));
        }
        function clearElement(id) {
            document.getElementById(id).value = '';
            updateCharCount(id, 'countScript');
        }
        function logStatus(msg) {
            const box = document.getElementById('statusLog');
            box.innerText += `\n[${new Date().toLocaleTimeString()}] ${msg}`;
            box.scrollTop = box.scrollHeight;
        }

        function openFile(event, targetId) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const target = document.getElementById(targetId);
                target.value += e.target.result;
                updateCharCount(targetId, 'countScript');
            };
            reader.readAsText(file);
            event.target.value = ''; 
        }
        function saveFile(sourceId, filename) {
            const text = document.getElementById(sourceId).value;
            if(!text) return alert("Nothing to save!");
            const blob = new Blob([text], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url; a.download = filename; a.click();
            URL.revokeObjectURL(url);
        }

        async function refineText() {
            const key = document.getElementById('geminiKey').value.trim();
            if(!key) return alert('Please enter Google AI Studio API key.');
            const script = document.getElementById('draftScript').value.trim();
            if(!script) return alert('Draft script is empty.');
            
            const btn = document.getElementById('btnRefine');
            const originalText = btn.innerHTML;
            btn.innerHTML = '‚è≥ Refining...';
            btn.disabled = true;

            const model = document.getElementById('geminiModel').value;
            const instruction = document.getElementById('voicePrompt').value;
            const fullPrompt = `System instructions: ${instruction}\n\nText to refine:\n${script}`;

            logStatus("Sending text to AI for refinement...");
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }] })
                });
                const data = await response.json();
                if(data.error) throw new Error(data.error.message);
                
                let resultText = data.candidates[0].content.parts[0].text.trim();
                
                document.getElementById('audioScript').value = resultText;
                updateCharCount('audioScript', 'countScript');
                
                logStatus("Text refinement complete. Ready for Audio Generation.");
                alert("Refined text has been placed in the Final Audio Script box!");
            } catch (err) {
                logStatus(`Error refining text: ${err.message}`);
                alert("Error: " + err.message);
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        const delay = ms => new Promise(res => setTimeout(res, ms));

        function stopProcess() {
            if(isProcessing) {
                isProcessing = false;
                logStatus("Process interrupted. Compiling generated audio...");
            }
        }

        function base64ToUint8Array(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes;
        }

        // --- üöÄ THE AUTO-SSML WRAPPER & FETCH FUNCTION üöÄ ---
        async function fetchTTS(rawTextChunk) {
            const voiceSelect = document.getElementById('ttsVoice');
            const voiceName = voiceSelect.value;
            
            // üåü NEW: Extract Language Code Dynamically based on the selected option!
            const langCode = voiceSelect.options[voiceSelect.selectedIndex].getAttribute('data-lang') || voiceName.substring(0, 5);

            const key = document.getElementById('cloudKey').value.trim();
            const format = document.getElementById('audioFormat').value;
            
            // Get Slider Values
            const rateStr = document.getElementById('ttsRate').value + "%";
            let pitchValue = document.getElementById('ttsPitch').value;
            const pitchStr = (pitchValue > 0 ? "+" + pitchValue : pitchValue) + "%";
            const volumeDb = parseFloat(document.getElementById('ttsVolume').value);

            let payload = {
                voice: { languageCode: langCode, name: voiceName },
                audioConfig: { 
                    audioEncoding: format,
                    volumeGainDb: volumeDb 
                }
            };

            // Remove any accidental HTML/XML tags from the raw text to be safe
            let cleanText = rawTextChunk.replace(/<[^>]+>/g, '').trim();

            if (voiceName.includes('Journey')) {
                // Journey Mode: Plain text only, no prosody allowed
                payload.input = { text: cleanText };
            } else if (voiceName.includes('Studio') || voiceName.includes('Chirp3')) {
                // üö® Studio & Chirp 3 HD Mode: Rate (Speed) is fully supported for natural pacing. Pitch is restricted.
                let wrappedSSML = `<speak>\n<prosody rate="${rateStr}">\n${cleanText}\n</prosody>\n</speak>`;
                payload.input = { ssml: wrappedSSML };
            } else {
                // ‚úÖ Neural2 & Polyglot Mode: Supports both rate and pitch perfectly
                let wrappedSSML = `<speak>\n<prosody rate="${rateStr}" pitch="${pitchStr}">\n${cleanText}\n</prosody>\n</speak>`;
                payload.input = { ssml: wrappedSSML };
            }

            const response = await fetch(`https://texttospeech.googleapis.com/v1/text:synthesize?key=${key}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const data = await response.json();
            if(data.error) throw new Error(data.error.message);
            return data.audioContent;
        }

        function chunkText(text, maxChars) {
            let chunks = [];
            let currentChunk = "";
            let segments = text.split(/(?<=\.|\?|\!|\n)\s+/); 
            
            for(let seg of segments) {
                if(!seg.trim()) continue;
                if((currentChunk.length + seg.length) > maxChars) {
                    if(currentChunk.trim()) {
                        chunks.push(currentChunk.trim());
                    }
                    currentChunk = seg + " ";
                } else {
                    currentChunk += seg + " ";
                }
            }
            if(currentChunk.trim()) {
                chunks.push(currentChunk.trim());
            }
            return chunks;
        }

        async function previewAudio() {
            if(!document.getElementById('cloudKey').value) return alert("Missing Google Cloud API Key.");
            let text = document.getElementById('audioScript').value;
            if(!text.trim()) return alert("No script to preview.");
            
            logStatus("Generating Preview...");
            isProcessing = true;
            try {
                let segments = text.split(/(?<=\.|\?|\!|\n)\s+/);
                let previewText = segments.slice(0, 5).join(' ').trim();
                
                const audioBase64 = await fetchTTS(previewText);
                const format = document.getElementById('audioFormat').value === 'MP3' ? 'audio/mpeg' : 'audio/wav';
                const audioBlob = new Blob([base64ToUint8Array(audioBase64)], { type: format });
                
                const audioUrl = URL.createObjectURL(audioBlob);
                const player = document.getElementById('audioPlayer');
                player.src = audioUrl;
                player.play();
                logStatus("Preview ready and playing.");
            } catch(e) {
                logStatus("Preview Error: " + e.message);
            }
            isProcessing = false;
        }

        async function startGeneration() {
            if(!document.getElementById('cloudKey').value) return alert("Missing Google Cloud API Key.");
            let text = document.getElementById('audioScript').value;
            if(!text.trim()) return alert("No script to process.");

            const batchSize = parseInt(document.getElementById('batchSize').value);
            const baseDelay = parseFloat(document.getElementById('batchDelay').value) * 1000;
            const format = document.getElementById('audioFormat').value === 'MP3' ? 'audio/mpeg' : 'audio/wav';

            const chunks = chunkText(text, batchSize);
            logStatus(`Starting generation. Total batches: ${chunks.length}`);
            
            isProcessing = true;
            audioChunksBlob = []; 
            document.getElementById('downloadBtn').disabled = true;

            const maxRetries = 3; // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà

            for(let i = 0; i < chunks.length; i++) {
                if(!isProcessing) break; 

                logStatus(`Processing Batch ${i+1}/${chunks.length}...`);
                
                let success = false;
                let retryCount = 0;

                while (!success && retryCount <= maxRetries && isProcessing) {
                    try {
                        const audioBase64 = await fetchTTS(chunks[i]);
                        audioChunksBlob.push(base64ToUint8Array(audioBase64));
                        success = true;
                        
                        if(i < chunks.length - 1 && isProcessing) {
                            const jitter = Math.random() * 2000;
                            const waitTime = baseDelay + jitter;
                            logStatus(`Waiting ${(waitTime/1000).toFixed(1)}s before next batch...`);
                            await delay(waitTime);
                        }
                    } catch(e) {
                        retryCount++;
                        if (retryCount <= maxRetries && isProcessing) {
                            logStatus(`‚ö†Ô∏è Error on batch ${i+1}: ${e.message}. Retrying (${retryCount}/${maxRetries}) in 5 seconds...`);
                            await delay(5000); // ‡∏£‡∏≠ 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
                        } else {
                            logStatus(`‚ùå Critical Error on batch ${i+1} after ${maxRetries} retries: ${e.message}`);
                            isProcessing = false;
                            break;
                        }
                    }
                }
            }

            compileAudio(format);
        }

        function compileAudio(mimeType) {
            if(audioChunksBlob.length === 0) {
                logStatus("No audio generated.");
                return;
            }
            logStatus("Compiling audio chunks...");
            
            const finalBlob = new Blob(audioChunksBlob, { type: mimeType });
            const audioUrl = URL.createObjectURL(finalBlob);
            
            const player = document.getElementById('audioPlayer');
            player.src = audioUrl;
            
            const dBtn = document.getElementById('downloadBtn');
            dBtn.onclick = () => {
                const a = document.createElement("a");
                a.href = audioUrl;
                a.download = `Audio_Export_${new Date().getTime()}.${mimeType === 'audio/mpeg' ? 'mp3' : 'wav'}`;
                a.click();
            };
            dBtn.disabled = false;
            
            isProcessing = false;
            logStatus(`‚úÖ Processing Complete! You can now play or download the audio.`);
        }
    </script>
</body>
</html>