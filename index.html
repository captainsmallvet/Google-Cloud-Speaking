<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Cloud Speaking (Pro Version)</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #121212; color: #e0e0e0; margin: 0; padding: 20px; box-sizing: border-box; }
        h1 { background: #1f1f1f; color: #8ab4f8; padding: 15px; text-align: center; border-radius: 8px; margin-top: 0; font-size: 24px; border: 1px solid #333;}
        .section { background: #1e1e1e; padding: 15px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border: 1px solid #333;}
        .row { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; align-items: center; }
        .row label { font-weight: bold; min-width: 120px; color: #b3b3b3; }
        input[type="text"], input[type="number"], select, textarea { padding: 10px; border: 1px solid #444; border-radius: 4px; flex-grow: 1; font-family: inherit; background-color: #2d2d2d; color: #ffffff; }
        input::placeholder, textarea::placeholder { color: #888; }
        textarea { width: 100%; resize: vertical; box-sizing: border-box; font-size: 16px; line-height: 1.6; }
        button { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s; background: #444; color: #e0e0e0; }
        button:hover:not(:disabled) { filter: brightness(1.2); }
        button:disabled { opacity: 0.6; cursor: not-allowed; }
        .btn-primary { background: #8ab4f8; color: #121212; }
        .btn-success { background: #81c995; color: #121212; }
        .btn-danger { background: #f28b82; color: #121212; }
        .status-box { background: #202124; color: #a8c7fa; padding: 10px; border-radius: 4px; border: 1px solid #444; font-family: monospace; white-space: pre-wrap; max-height: 150px; overflow-y: auto; }
        input[type="file"] { display: none; }
        audio { filter: invert(0.9) hue-rotate(180deg); }
        .char-count { margin-left: auto; color: #8ab4f8; font-family: monospace; font-size: 14px; font-weight: bold; background: #2d2d2d; padding: 5px 10px; border-radius: 4px; border: 1px solid #444;}
    </style>
</head>
<body>

    <h1>üéôÔ∏è Google Cloud Speaking</h1>

    <div class="section">
        <h3 style="color: #fff;">üîë API Key Management</h3>
        <div class="row">
            <label>Google AI Studio:</label>
            <input type="text" id="geminiKey" placeholder="no API key">
            <button onclick="saveKey('geminiKey')">Send (Save)</button>
            <button onclick="copyElement('geminiKey')">Copy</button>
            <button class="btn-danger" onclick="clearKey('geminiKey')">Clear</button>
        </div>
        <div class="row">
            <label>Google Cloud TTS:</label>
            <input type="text" id="cloudKey" placeholder="no API key">
            <button onclick="saveKey('cloudKey')">Send (Save)</button>
            <button onclick="copyElement('cloudKey')">Copy</button>
            <button class="btn-danger" onclick="clearKey('cloudKey')">Clear</button>
        </div>
    </div>

    <div class="section">
        <h3 style="color: #fff;">‚öôÔ∏è Global Settings</h3>
        <div class="row">
            <label>AI Text Model:</label>
            <select id="geminiModel">
                <option value="gemini-3-flash-preview" selected>Gemini 3 Flash Preview (Default)</option>
                <option value="gemini-flash-latest">Gemini Flash Latest</option>
                <option value="gemini-flash-lite-latest">Gemini Flash Lite Latest</option>
                <option value="gemini-2.5-flash">gemini-2.5-flash</option>
            </select>
        </div>
        <div class="row">
            <label>Cloud TTS Voice:</label>
            <select id="ttsVoice" onchange="loadPreset()">
                <option value="en-US-Studio-Q" selected>en-US-Studio-Q (Male - Studio)</option>
                <option value="en-US-Neural2-J">en-US-Neural2-J (Male - Neural2 Deep)</option>
                <option value="en-US-Neural2-I">en-US-Neural2-I (Male - Neural2 Smooth)</option>
                <option value="en-US-Neural2-D">en-US-Neural2-D (Male - Neural2 Mature)</option>
                <option value="en-US-Studio-O">en-US-Studio-O (Female - Studio)</option>
                <option value="en-US-Journey-D">en-US-Journey-D (Male - Journey)</option>
            </select>
            <label>Format:</label>
            <select id="audioFormat">
                <option value="MP3" selected>MP3 (Best for long audio/RAM)</option>
                <option value="LINEAR16">WAV (High Quality, Huge file size)</option>
            </select>
        </div>
        <div class="row">
            <label>API Global Pitch:</label>
            <input type="number" id="ttsPitch" value="0.0" step="0.1">
            <label>API Global Rate:</label>
            <input type="number" id="ttsRate" value="1.0" step="0.05">
            <label>Volume Gain (dB):</label>
            <input type="number" id="ttsVolume" value="0.0" step="0.5">
        </div>
        
        <div class="row" style="justify-content: space-between; margin-top: 15px;">
            <label>AI SSML Prompt Preset:</label>
            <select id="promptPresetSelect" onchange="loadPreset()" style="max-width: 400px; border-color: #8ab4f8;">
                <option value="dhamma">üßò‚Äç‚ôÇÔ∏è Calm Dhamma Narration (Rate 30% / No Breaks)</option>
                <option value="commercial">üé¨ Energetic Commercial</option>
            </select>
        </div>
        <div class="row">
            <textarea id="voicePrompt" rows="8">Loading rules...</textarea>
        </div>
    </div>

    <div class="section">
        <h3 style="color: #fff;">üìÑ Primary Audio Script</h3>
        <div class="row">
            <input type="file" id="filePrimary" accept=".txt" onchange="openFile(event, 'primaryScript')">
            <button onclick="document.getElementById('filePrimary').click()">Open (.txt)</button>
            <button onclick="saveFile('primaryScript', 'primary_audio_script.txt')">Save</button>
            <button onclick="copyElement('primaryScript')">Copy</button>
            <button class="btn-danger" onclick="clearElement('primaryScript')">Clear</button>
            <span class="char-count" id="countPrimary">0 Chars</span>
        </div>
        <textarea id="primaryScript" rows="12" placeholder="Paste your English text here..."></textarea>
    </div>

    <div class="section">
        <h3 style="color: #fff;">üìù SSML Audio Script</h3>
        <div class="row">
            <button id="btnGenerateSSML" class="btn-primary" onclick="generateSSML()">‚ú® Generate SSML from Script</button>
            <input type="file" id="fileSSML" accept=".txt" onchange="openFile(event, 'ssmlScript')">
            <button onclick="document.getElementById('fileSSML').click()">Open (.txt)</button>
            <button onclick="saveFile('ssmlScript', 'SSML_audio_script.txt')">Save</button>
            <button onclick="copyElement('ssmlScript')">Copy</button>
            <button class="btn-danger" onclick="clearElement('ssmlScript')">Clear</button>
            <span class="char-count" id="countSSML">0 Chars</span>
        </div>
        <textarea id="ssmlScript" rows="12" placeholder="Generated SSML will appear here..."></textarea>
    </div>

    <div class="section">
        <h3 style="color: #fff;">üéõÔ∏è Processing Controls & Output</h3>
        <div class="row">
            <label>Batch Size (Chars):</label>
            <input type="number" id="batchSize" value="3500">
            <label>Inter-batch Delay (Sec):</label>
            <input type="number" id="batchDelay" value="3" step="0.5">
        </div>
        <div class="row">
            <button class="btn-primary" onclick="previewAudio()">‚ñ∂Ô∏è Preview (First 5 sentences)</button>
            <button class="btn-success" onclick="startGeneration()">üöÄ Generate Full Audio</button>
            <button class="btn-danger" onclick="stopProcess()">‚èπÔ∏è Stop</button>
        </div>
        
        <h4 style="color: #fff; margin-bottom: 5px;">Status:</h4>
        <div class="row">
            <button onclick="copyElement('statusLog')">Copy Status</button>
        </div>
        <div id="statusLog" class="status-box">Ready.</div>

        <h4 style="color: #fff; margin-bottom: 5px;">Audio Player:</h4>
        <div class="row">
            <audio id="audioPlayer" controls style="width: 100%;"></audio>
        </div>
        <div class="row">
            <button class="btn-success" id="downloadBtn" onclick="downloadAudio()" disabled>üíæ Download Audio</button>
        </div>
    </div>

    <script>
        let isProcessing = false;
        let audioChunksBlob = []; 

        const promptPresets = {
            "dhamma": "Please format the SSML for a Buddhist Dhamma narration in English. The tone must be deep, calming, warm, empathetic, and trustworthy. Wrap the entire text in a single <prosody rate=\"30%\"> tag. CRITICAL INSTRUCTION: DO NOT use any <break> tags anywhere in the SSML. Let the natural punctuation guide the pauses.",
            "commercial": "Please format the SSML for an energetic commercial. Keep the pacing upbeat."
        };

        function loadPreset() {
            const selected = document.getElementById('promptPresetSelect').value;
            const voiceName = document.getElementById('ttsVoice').value;
            let basePrompt = promptPresets[selected];
            
            basePrompt += "\n\n*** CRITICAL SSML RULES FOR GOOGLE CLOUD TTS ***\n";
            basePrompt += "1. NEVER use <emphasis> tags.\n";
            
            if (voiceName.includes('Journey')) {
                basePrompt += "2. üö® CRITICAL: You are generating for a 'Journey' voice. You MUST NOT use <prosody> tags. Use text only.";
            } else if (voiceName.includes('Neural2')) {
                basePrompt += "2. You MAY use the 'pitch' attribute in <prosody> (e.g., pitch=\"-10%\") to deepen the tone for this Neural2 voice.\n";
                basePrompt += "3. Ensure you ALWAYS close <prosody> with </prosody>.";
            } else {
                basePrompt += "2. DO NOT use the 'pitch' attribute in SSML, as it is disabled for Studio voices.\n";
                basePrompt += "3. Ensure you ALWAYS close <prosody> with </prosody>.";
            }
            
            document.getElementById('voicePrompt').value = basePrompt;
        }
        
        window.onload = () => {
            loadKey('geminiKey');
            loadKey('cloudKey');
            updateCharCount('primaryScript', 'countPrimary');
            updateCharCount('ssmlScript', 'countSSML');
            loadPreset(); 
        };

        document.getElementById('primaryScript').addEventListener('input', () => updateCharCount('primaryScript', 'countPrimary'));
        document.getElementById('ssmlScript').addEventListener('input', () => updateCharCount('ssmlScript', 'countSSML'));

        function updateCharCount(inputId, displayId) {
            const textLength = document.getElementById(inputId).value.length;
            document.getElementById(displayId).innerText = `${textLength.toLocaleString()} Chars`;
        }

        function saveKey(id) {
            const val = document.getElementById(id).value.trim();
            if(val) { localStorage.setItem(id, val); alert('Key saved to browser storage.'); }
        }
        function loadKey(id) {
            const val = localStorage.getItem(id);
            if(val) document.getElementById(id).value = val;
        }
        function clearKey(id) {
            localStorage.removeItem(id);
            document.getElementById(id).value = '';
            document.getElementById(id).placeholder = 'no API key';
        }

        function copyElement(id) {
            const el = document.getElementById(id);
            const text = el.tagName === 'DIV' ? el.innerText : el.value;
            navigator.clipboard.writeText(text).then(() => alert('Copied to clipboard.'));
        }
        function clearElement(id) {
            const el = document.getElementById(id);
            if(el.tagName === 'DIV') el.innerText = ''; else el.value = '';
            if(id === 'primaryScript') updateCharCount('primaryScript', 'countPrimary');
            if(id === 'ssmlScript') updateCharCount('ssmlScript', 'countSSML');
        }
        function logStatus(msg) {
            const box = document.getElementById('statusLog');
            box.innerText += `\n[${new Date().toLocaleTimeString()}] ${msg}`;
            box.scrollTop = box.scrollHeight;
        }

        function openFile(event, targetId) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const target = document.getElementById(targetId);
                const textToInsert = e.target.result;
                const startPos = target.selectionStart;
                const endPos = target.selectionEnd;
                target.value = target.value.substring(0, startPos) + textToInsert + target.value.substring(endPos, target.value.length);
                if(targetId === 'primaryScript') updateCharCount('primaryScript', 'countPrimary');
                if(targetId === 'ssmlScript') updateCharCount('ssmlScript', 'countSSML');
            };
            reader.readAsText(file);
            event.target.value = ''; 
        }
        function saveFile(sourceId, filename) {
            const text = document.getElementById(sourceId).value;
            if(!text) return alert("Nothing to save!");
            const blob = new Blob([text], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url; a.download = filename; a.click();
            URL.revokeObjectURL(url);
        }

        async function generateSSML() {
            const key = document.getElementById('geminiKey').value.trim();
            if(!key) return alert('Please enter Google AI Studio API key.');
            const script = document.getElementById('primaryScript').value.trim();
            if(!script) return alert('Primary script is empty.');
            
            const btn = document.getElementById('btnGenerateSSML');
            const originalText = btn.innerHTML;
            btn.innerHTML = '‚è≥ Processing... Please wait';
            btn.disabled = true;

            const model = document.getElementById('geminiModel').value;
            const promptInstruction = document.getElementById('voicePrompt').value;
            const fullPrompt = `System instructions: ${promptInstruction}\n\nTask: Convert the following text into valid SSML format. ONLY return the raw SSML code without any markdown blocks (like \`\`\`xml) or explanations. Ensure the whole text is wrapped in <speak></speak> tags.\n\nText:\n${script}`;

            logStatus("Generating SSML via Gemini...");
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }] })
                });
                const data = await response.json();
                if(data.error) throw new Error(data.error.message);
                
                let ssmlResult = data.candidates[0].content.parts[0].text;
                ssmlResult = ssmlResult.replace(/```xml/gi, '').replace(/```html/gi, '').replace(/```/g, '').trim();
                
                if(!ssmlResult.startsWith('<speak>')) ssmlResult = `<speak>\n${ssmlResult}`;
                if(!ssmlResult.endsWith('</speak>')) ssmlResult = `${ssmlResult}\n</speak>`;

                document.getElementById('ssmlScript').value = ssmlResult;
                updateCharCount('ssmlScript', 'countSSML');
                
                logStatus("SSML Generation Complete.");
            } catch (err) {
                logStatus(`Error generating SSML: ${err.message}`);
                alert("Error: " + err.message);
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        const delay = ms => new Promise(res => setTimeout(res, ms));

        function stopProcess() {
            if(isProcessing) {
                isProcessing = false;
                logStatus("Process interrupted by user. Compiling generated chunks...");
            }
        }

        function base64ToUint8Array(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes;
        }

        // --- üöÄ FETCH FUNCTION WITH NEURAL2 PITCH SUPPORT üöÄ ---
        async function fetchTTS(ssmlText) {
            const voiceName = document.getElementById('ttsVoice').value;
            const key = document.getElementById('cloudKey').value.trim();
            const format = document.getElementById('audioFormat').value;
            
            let payload = {
                voice: { languageCode: "en-US", name: voiceName },
                audioConfig: { audioEncoding: format }
            };

            if (voiceName.includes('Journey')) {
                let plainText = ssmlText;
                plainText = plainText.replace(/<break[^>]*>/gi, '\n\n');
                plainText = plainText.replace(/<[^>]+>/g, '');
                plainText = plainText.replace(/\n\s*\n/g, '\n\n');
                payload.input = { text: plainText.trim() };
            } else {
                let cleanSSML = ssmlText;
                cleanSSML = cleanSSML.replace(/<emphasis[^>]*>/gi, '').replace(/<\/emphasis>/gi, '');
                
                // ‚ú® ‡πÑ‡∏Æ‡πÑ‡∏•‡∏ó‡πå: ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á Pitch ‡πÑ‡∏ß‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡πÄ‡∏™‡∏µ‡∏¢‡∏á Neural2!
                if (!voiceName.includes('Neural2')) {
                    cleanSSML = cleanSSML.replace(/pitch="[^"]*"/gi, ''); 
                }

                cleanSSML = cleanSSML.replace(/time="(\d*\.?\d+)s"/gi, (match, p1) => {
                    return 'time="' + Math.round(parseFloat(p1) * 1000) + 'ms"';
                });

                cleanSSML = cleanSSML.replace(/<prosody\s+>/gi, '<prosody>'); 
                const openProsodyCount = (cleanSSML.match(/<prosody[^>]*>/gi) || []).length;
                const closeProsodyCount = (cleanSSML.match(/<\/prosody>/gi) || []).length;
                
                if (openProsodyCount > closeProsodyCount) {
                    cleanSSML = cleanSSML.replace(/<\/speak>/gi, '');
                    for(let i = 0; i < (openProsodyCount - closeProsodyCount); i++) {
                        cleanSSML += '</prosody>';
                    }
                    cleanSSML += '</speak>';
                }

                payload.input = { ssml: cleanSSML };
                
                payload.audioConfig.pitch = parseFloat(document.getElementById('ttsPitch').value);
                payload.audioConfig.speakingRate = parseFloat(document.getElementById('ttsRate').value);
                payload.audioConfig.volumeGainDb = parseFloat(document.getElementById('ttsVolume').value);
            }

            const response = await fetch(`https://texttospeech.googleapis.com/v1/text:synthesize?key=${key}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const data = await response.json();
            if(data.error) throw new Error(data.error.message);
            return data.audioContent;
        }

        function getOpenTags(ssml) {
            const openTags = [];
            const regex = /<(\/?)([a-zA-Z0-9\-:]+)([^>]*)>/g;
            let match;
            while ((match = regex.exec(ssml)) !== null) {
                const isClosing = match[1] === '/';
                const tagName = match[2].toLowerCase();
                const attributes = match[3];
                
                if (attributes.trim().endsWith('/')) continue;
                if (['break', 'mark'].includes(tagName)) continue;

                if (!isClosing) {
                    openTags.push({ name: tagName, full: match[0] });
                } else {
                    const index = openTags.map(t => t.name).lastIndexOf(tagName);
                    if (index !== -1) openTags.splice(index, 1);
                }
            }
            return openTags; 
        }

        async function previewAudio() {
            if(!document.getElementById('cloudKey').value) return alert("Missing Google Cloud API Key.");
            let ssml = document.getElementById('ssmlScript').value;
            if(!ssml) return alert("No SSML to preview.");
            
            logStatus("Generating Preview...");
            isProcessing = true;
            try {
                let innerText = ssml.replace(/<\/?speak>/gi, '').trim();
                let segments = innerText.split(/(?<=\.|\?|\!)\s+|\n\n/); 
                let previewText = segments.slice(0, 5).join(' '); 
                
                let tagsToClose = getOpenTags(previewText);
                for (let i = tagsToClose.length - 1; i >= 0; i--) {
                    previewText += `</${tagsToClose[i].name}>`;
                }
                
                const safeSSML = `<speak>${previewText}</speak>`;
                
                const audioBase64 = await fetchTTS(safeSSML);
                const format = document.getElementById('audioFormat').value === 'MP3' ? 'audio/mpeg' : 'audio/wav';
                const audioBlob = new Blob([base64ToUint8Array(audioBase64)], { type: format });
                
                const audioUrl = URL.createObjectURL(audioBlob);
                const player = document.getElementById('audioPlayer');
                player.src = audioUrl;
                player.play();
                logStatus("Preview ready and playing.");
            } catch(e) {
                logStatus("Preview Error: " + e.message);
            }
            isProcessing = false;
        }

        function chunkSSML(ssml, maxChars) {
            let chunks = [];
            let currentChunk = "";
            let innerText = ssml.replace(/<\/?speak>/gi, '').trim(); 
            let segments = innerText.split(/(?<=\.|\?|\!)\s+|\n\n/); 
            
            let activeTags = []; 
            
            for(let seg of segments) {
                if((currentChunk.length + seg.length) > maxChars) {
                    if(currentChunk.trim()) {
                        let chunkToPush = currentChunk.trim();
                        let tagsToClose = getOpenTags(chunkToPush);
                        for (let i = tagsToClose.length - 1; i >= 0; i--) {
                            chunkToPush += `</${tagsToClose[i].name}>`;
                        }
                        chunks.push(`<speak>${chunkToPush}</speak>`);
                        
                        activeTags = tagsToClose; 
                    }
                    currentChunk = activeTags.map(t => t.full).join('') + seg + " ";
                } else {
                    currentChunk += seg + " ";
                }
            }
            if(currentChunk.trim()) {
                let chunkToPush = currentChunk.trim();
                let tagsToClose = getOpenTags(chunkToPush);
                for (let i = tagsToClose.length - 1; i >= 0; i--) {
                    chunkToPush += `</${tagsToClose[i].name}>`;
                }
                chunks.push(`<speak>${chunkToPush}</speak>`);
            }
            return chunks;
        }

        async function startGeneration() {
            if(!document.getElementById('cloudKey').value) return alert("Missing Google Cloud API Key.");
            let ssml = document.getElementById('ssmlScript').value;
            if(!ssml) return alert("No SSML to process.");

            const batchSize = parseInt(document.getElementById('batchSize').value);
            const baseDelay = parseFloat(document.getElementById('batchDelay').value) * 1000;
            const format = document.getElementById('audioFormat').value === 'MP3' ? 'audio/mpeg' : 'audio/wav';

            const chunks = chunkSSML(ssml, batchSize);
            logStatus(`Starting generation. Total batches: ${chunks.length}`);
            
            isProcessing = true;
            audioChunksBlob = []; 
            document.getElementById('downloadBtn').disabled = true;

            for(let i = 0; i < chunks.length; i++) {
                if(!isProcessing) break; 

                logStatus(`Processing Batch ${i+1}/${chunks.length}... \nPreview: ${chunks[i].replace(/<[^>]+>/g, '').substring(0, 50)}...`);
                
                try {
                    const audioBase64 = await fetchTTS(chunks[i]);
                    audioChunksBlob.push(base64ToUint8Array(audioBase64));
                    
                    if(i < chunks.length - 1 && isProcessing) {
                        const jitter = Math.random() * 2000;
                        const waitTime = baseDelay + jitter;
                        logStatus(`Waiting ${(waitTime/1000).toFixed(1)}s before next batch...`);
                        await delay(waitTime);
                    }
                } catch(e) {
                    logStatus(`Error on batch ${i+1}: ${e.message}`);
                    isProcessing = false;
                    break;
                }
            }

            compileAudio(format);
        }

        function compileAudio(mimeType) {
            if(audioChunksBlob.length === 0) {
                logStatus("No audio generated.");
                return;
            }
            logStatus("Compiling audio chunks...");
            
            const finalBlob = new Blob(audioChunksBlob, { type: mimeType });
            const audioUrl = URL.createObjectURL(finalBlob);
            
            const player = document.getElementById('audioPlayer');
            player.src = audioUrl;
            
            const dBtn = document.getElementById('downloadBtn');
            dBtn.onclick = () => {
                const a = document.createElement("a");
                a.href = audioUrl;
                a.download = `Generated_Audio_${new Date().getTime()}.${mimeType === 'audio/mpeg' ? 'mp3' : 'wav'}`;
                a.click();
            };
            dBtn.disabled = false;
            
            isProcessing = false;
            logStatus(`‚úÖ Processing Complete! You can now play or download the audio.`);
        }
    </script>
</body>
</html>